@page "/"
@using PondSharp.UserScripts
@using PondSharp.Client.Pond
@using PondSharp.Client.IDE
@using System.Timers
@inject HttpClient Http


<div class="container-fluid">
    <div class="row">
        <div class="col">
            <h1>PondSharp</h1>
            <div class="blockquote">
                An alpha techdemo of in-browser C# (.NET Standard) compiliation and injection into WASM.
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-auto" style="width: @(PondWidth * GridSize + 10)px">
            <PondCanvas @ref="_canvas" Width="@PondWidth" Height="@PondHeight" GridSize="@GridSize"></PondCanvas>
            <div class="btn-group">
                <button class="btn btn-primary" @onclick="CompileSource" disabled="@(!_compilerReady)">Compile</button>
                <button class="btn btn-success" @onclick="StartPond" disabled="@(!IsCompiled || IsRunning)">Start</button>
                <button class="btn btn-warning" @onclick="StopPond" disabled="@(!IsRunning)">Stop</button>
                <button class="btn btn-danger" @onclick="Reset" disabled="@(!IsRunning)">Reset</button>
            </div>
            <div class="row">
                <div class="col">
                    <h3>Create Entities:</h3>
                    @if (IsCompiled)
                    {
                        @foreach (var (type, name) in _availableEntityTypes)
                        {
                            
                            <div class="input-group">
                                <div class="input-group-prepend">
                                    <span class="input-group-text">@name</span>
                                </div>
                                <input class="form-control" type="number" @bind="_countToCreate[type]" min="1" />
                                <div class="input-group-append">
                                    <button class="btn btn-info" @onclick="@(e => CreateEntity(type))">Create</button>
                                </div>
                            </div>
                        }
                    }
                </div>
                <div class="col w-25">
                    <div>
                        <h3>Stats:</h3>
                        <div style="font-family: monospace">TPS: <span>@(Math.Ceiling(1000 / (_manager?.CurrentTickTime ?? 1)))</span></div>
                        <div style="font-family: monospace">Entities: <span>@(_engine?.Entities.Count() ?? 0)</span></div>
                        <div style="font-family: monospace">@_output</div>
                    </div>
                </div>
            </div>
        </div>
        <div class="col overflow-hidden">
            <IdeElement @ref="_ideElement"></IdeElement>
            @if (_errors.Count > 0)
            {
                <div class="pre-scrollable bg-warning">
                    @foreach (var error in _errors)
                    {
                        <div class="border-bottom">@error</div>
                    }
                </div>
            }
        </div>
    </div>
    <hr />
    <div class="row">
        <div class="col">
            <p>
                <strong>How:</strong> Edit code with the editor on the right. Any changes you make are
                automatically save to localStorage. Once ready, click "Compile" to compile and load
                the generated assembly into the simulation. You can then create instances of each found entity which
                extends AbstractEntity and load them into the world. Once ready, click "Start"!
            </p>
            <p>
                Under the create entities, you can choose how many you want to create. To clear out all the entities,
                click "Reset". Recompiling will also clear out all existing entities.
            </p>
            <p>
                <strong>Who:</strong> This project was made by
                <a href="https://github.com/mrkmg">Kevin Gravier</a> and will eventually become open-sourced.
            </p>
            <p>
                <strong>What:</strong> A simulation to tech demo in browser c# .Net Standard compilation and execution.
            </p>
            <p>
                <strong>Where:</strong>
                <a href="https://mrkmg.github.io/PondSharp/">https://mrkmg.github.io/PondSharp/</a>
            </p>
            <p>
                <strong>When:</strong> © 2020 Kevin Gravier - all rights reserved.
            </p>
            <p>
                <strong>Why:</strong> This was made mostly out of curiosity of the ability to compile and run c# in the
                browser with Blazor. This may or may not turn into something more.
            </p>
        </div>
    </div>
</div>

@code
{
    private string _output = "No Instance Loaded";
    private IList<string> _errors = new List<string>();
    private CSharpClassCompiler _compiler;
    private bool _compilerReady;
    
    private (string, string)[] _availableEntityTypes = new (string, string)[0];
    private Dictionary<string, int> _countToCreate = new Dictionary<string, int>();
    
    private PondEngine _engine;
    private PondCanvas _canvas;
    private PondManager _manager;
    private IdeElement _ideElement;
    
    const int GridSize = 2;
    const int PondWidth = 300;
    const int PondHeight = 300;


    private bool IsCompiled => _compiler?.HasAssembly ?? false;
    private bool IsRunning => _manager?.IsRunning ?? false;
    
    private Timer _debugUpdateTimer = new Timer();

    protected override async Task OnInitializedAsync()
    {
        _debugUpdateTimer.Elapsed += (_,__) => StateHasChanged();
        var types = new List<Type>
        {
            typeof(object),
            typeof(AbstractEntity),
            typeof(System.Drawing.Color),
            typeof(Enumerable)
        };
        _compiler = await CSharpClassCompiler.Make(types, Http.BaseAddress);
        _compilerReady = true;
        _engine = new PondEngine(-PondWidth/2, PondWidth/2-1, -PondHeight/2, PondHeight/2-1);
        TryCreatePondManager();
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (!firstRender) return;
        
        TryCreatePondManager();
    }

    private void TryCreatePondManager()
    {
        if (_manager == null && _engine != null && _canvas != null)
        {
            _manager = new PondManager(_engine, _canvas);
        }
    }

    private void CreateEntity(string fullName)
    {
        for (var i = 0; i < _countToCreate[fullName]; i++) 
            RealCreateEntity(fullName);
    }
    
    private void RealCreateEntity(string fullName)
    {
        _manager.InitializeAndCreateEntity(_compiler.New<AbstractEntity>(fullName));
    }

    private async Task CompileSource()
    {
        await Reset();

        try
        {
            await _ideElement.TriggerSave();
            _output = "Compiling";
            _errors.Clear();
            StateHasChanged();
            await Task.Delay(TimeSpan.FromMilliseconds(100));
            _compiler.Compile(_ideElement.Sources);
            _availableEntityTypes = _compiler
                .AvailableInstances(typeof(AbstractEntity))
                .Select(t => (t, t.Split('.').Last()))
                .ToArray();
            if (_availableEntityTypes.Length == 0) throw new Exception("No found classes which extend AbstractEntity");
            _countToCreate = _availableEntityTypes.Select(t => (t.Item1, 10)).ToDictionary(t => t.Item1, t => t.Item2);
            _output = "Ready";

            StateHasChanged();
        }
        catch (CompileException e)
        {
            _errors = e.Errors.ToList();
            _output = "Compilation Failure";
            StateHasChanged();
        }
        catch (Exception e)
        {
            _errors = new List<string>(new[] {e.Message});
            _output = "Unknown Failure";
            StateHasChanged();
        }
    }

    private async Task StartPond()
    {
        await _manager.Start();
        _debugUpdateTimer.Start();
        _output = "Running";
    }

    private async Task StopPond()
    {
        await _manager.Stop();
        _debugUpdateTimer.Stop();
        _output = "Running";
    }

    private async Task Reset()
    {
        foreach (var instance in _engine.Entities)
        {
            await _canvas.DestroyEntity(instance.Id);
        }
        _engine.ClearAllEntities();
        await StopPond();
    }

}
