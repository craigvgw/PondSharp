@page "/"
@using PondSharp.UserScripts
@using PondSharp.Client.Pond
@using System.Timers
@using System.Drawing
@inject HttpClient Http
<!-- ReSharper disable once InconsistentNaming -->
@inject IJSRuntime JSRuntime
@inject Blazored.LocalStorage.ILocalStorageService LocalStorage


<div class="container-fluid">
    <div class="row">
        <div class="col">
            <h1>PondSharp</h1>
            <div class="blockquote">
                An alpha techdemo of in-browser C# (.NET Standard) compiliation and injection into WASM.
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-auto" style="width: @(PondWidth * GridSize + 10)px">
            <PondCanvas @ref="_canvas" Width="@PondWidth" Height="@PondHeight" GridSize="@GridSize"></PondCanvas>
            <div class="btn-group">
                <button class="btn btn-primary" @onclick="CompileSource" disabled="@(!_compilerReady)">Compile</button>
                <button class="btn btn-success" @onclick="StartPond" disabled="@(!IsCompiled)">Start</button>
                <button class="btn btn-warning" @onclick="StopPond" disabled="@(!IsCompiled)">Stop</button>
                <button class="btn btn-danger" @onclick="Reset" disabled="@(!IsCompiled)">Reset</button>
            </div>
            @if (IsCompiled)
            {
                <h3>Create Entities:</h3>
                @foreach (var (type, name) in _availableEntityTypes)
                {
                    
                    <div class="input-group">
                        <div class="input-group-prepend">
                            <span class="input-group-text">@name</span>
                        </div>
                        <input class="form-control" type="number" @bind="_countToCreate[type]" min="1" />
                        <div class="input-group-append">
                            <button class="btn btn-info" @onclick="@(e => CreateEntity(type))">Create</button>
                        </div>
                    </div>
                }
            }
            <div>
                <h3>Stats:</h3>
                <div style="font-family: monospace">TPS: <span>@(Math.Ceiling(1000 / (_manager?.CurrentTickTime ?? 1)))</span></div>
                <div style="font-family: monospace">Entities: <span>@(_engine?.Entities.Count() ?? 0)</span></div>
                <div style="font-family: monospace">@_output</div>
            </div>
        </div>
        <div class="col overflow-hidden">
            <div class="btn-group btn-group-sm">
                @foreach (var name in _sources.Keys)
                {
                    <button class="nav-item btn @(_selectedSource == name ? "btn-primary" : "btn-secondary")" @onclick="@(e => SelectSource(name))">@name</button>
                }
            </div>
            <div id="code-editor" class="w-auto" style="min-height: 500px; height: calc(100vh - 200px)"></div>
        </div>
    </div>
</div>

@code
{
    private string _output = "No Instance Loaded";
    private Dictionary<string, string> _sources = new Dictionary<string, string>();
    private string _selectedSource = string.Empty;
    private CSharpClassCompiler _compiler;
    private bool _compilerReady;
    
    private (string, string)[] _availableEntityTypes = new (string, string)[0];
    private Dictionary<string, int> _countToCreate = new Dictionary<string, int>();
    
    private PondEngine _engine;
    private PondCanvas _canvas;
    private PondManager _manager;
    
    const int GridSize = 1;
    const int PondWidth = 400;
    const int PondHeight = 400;
    
    private bool IsCompiled => _compiler?.HasAssembly ?? false;
    
    private readonly Random _random = new Random();
    
    private Timer _debugUpdateTimer = new Timer();

    protected override async Task OnInitializedAsync()
    {
        _debugUpdateTimer.Elapsed += (_,__) => StateHasChanged();
        var types = new List<Type>
        {
            typeof(object),
            typeof(AbstractEntity),
            typeof(System.Drawing.Color),
            typeof(Enumerable)
        };
        _compiler = await CSharpClassCompiler.Make(types, Http.BaseAddress);
        _compilerReady = true;
        _engine = new PondEngine(-PondWidth/2, PondWidth/2-1, -PondHeight/2, PondHeight/2-1);
        TryCreatePondManager();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;
        
        await CreateEditor();
        TryCreatePondManager();
    }

    private void TryCreatePondManager()
    {
        if (_manager == null && _engine != null && _canvas != null)
        {
            _manager = new PondManager(_engine, _canvas);
        }
    }

    private async Task CreateEditor()
    {
        await JSRuntime.InvokeVoidAsync("createEditor", "code-editor", "codeEditor");
        await ReadSources();
        await SelectSource(_sources.First().Key);
    }

    private async Task SaveSource()
    {
        _sources[_selectedSource] = await JSRuntime.InvokeAsync<string>("codeEditor.getCode");
        await WriteAllSources();
    }

    private ValueTask WriteAllSources() => LocalStorage.SetItemAsync("savedScripts", _sources);

    private async Task FetchExampleSources()
    {
        var sourceFiles = new []
        {
            "BaseEntity.cs",
            "Simple.cs",
            "Complex.cs"
        };
        _sources.Clear();
        foreach (var sourceFile in sourceFiles)
        {
            var code = await Http.GetStringAsync($"user-scripts/{sourceFile}.txt");
            _sources.Add(sourceFile, code);
        }
    }

    private async Task ReadSources()
    {
        var hasLocalScripts = await LocalStorage.ContainKeyAsync("savedScripts");
        if (!hasLocalScripts)
        {
            await FetchExampleSources();
            return;
        }
        _sources = await LocalStorage.GetItemAsync<Dictionary<string, string>>("savedScripts");
    } 
    
    private async Task SelectSource(string source)
    {
        if (_selectedSource != string.Empty) await SaveSource();
        _selectedSource = source;
        await JSRuntime.InvokeVoidAsync("codeEditor.setCode", _sources[source]);
    }

    private void CreateEntity(string fullName)
    {
        for (var i = 0; i < _countToCreate[fullName]; i++) 
            RealCreateEntity(fullName);
    }
    
    private void RealCreateEntity(string fullName)
    {
        _manager.InitializeAndCreateEntity(_compiler.New<AbstractEntity>(fullName));
    }

    private async Task CompileSource()
    {
        await Reset();
        
        try
        {
            await SaveSource();
            _output = "Compiling";
            StateHasChanged();
            await Task.Delay(TimeSpan.FromMilliseconds(100));
            _compiler.Compile(_sources.Values);
            _availableEntityTypes = _compiler
                .AvailableInstances(typeof(AbstractEntity))
                .Select(t => (t, t.Split('.').Last()))
                .ToArray();
            if (_availableEntityTypes.Length == 0) throw new Exception("No found classes which extend AbstractEntity");
            _countToCreate = _availableEntityTypes.Select(t => (t.Item1, 10)).ToDictionary(t => t.Item1, t => t.Item2);
            _output = "Ready";
            
            StateHasChanged();
        }
        catch (Exception e)
        {
            _output = e.Message;
            StateHasChanged();
        }
    }

    private async Task StartPond()
    {
        await _manager.Start();
        _debugUpdateTimer.Start();
        _output = "Running";
    }

    private async Task StopPond()
    {
        await _manager.Stop();
        _debugUpdateTimer.Stop();
        _output = "Running";
    }

    private async Task Reset()
    {
        foreach (var instance in _engine.Entities)
        {
            await _canvas.DestroyEntity(instance.Id);
        }
        _engine.ClearAllEntities();
        await StopPond();
    }


}
